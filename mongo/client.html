<div class='index'>

<ul>
<li><a href="#struct-client">Struct <code>Client</code></a> - User interfaces with <code>Client</code>, which processes user requests and sends them through the connection.</li>
<li><a href="#implementation-for-client">Implementation <code>for Client</code></a></li>
</ul>
</div>

<h2 id="struct-client">Struct <code>Client</code></h2>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">struct</span> Client {
    conn: cell::Cell&lt;NodeConnection&gt;,
    <span class="kw">priv</span> cur_requestId: ~cell::Cell&lt;<span class="kw">i32</span>&gt;,
}</code></pre>
<p>User interfaces with <code>Client</code>, which processes user requests and sends them through the connection.</p>
<p>All communication to server goes through <code>Client</code>, i.e. <code>DB</code>, <code>Collection</code>, etc. all store their associated <code>Client</code></p>
<h2 id="implementation-for-client">Implementation for <code>Client</code></h2>
<h3 id="method-new">Method <code>new</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> new() -&gt; Client</code></pre>
<p>Creates a new Mongo client.</p>
<p>Currently can connect to single unreplicated, unsharded server via <code>connect</code>.</p>
<h4 id="returns">Returns</h4>
<p>empty <code>Client</code></p>
<h3 id="method-get_admin">Method <code>get_admin</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> get_admin(@self) -&gt; DB</code></pre>
<h3 id="method-get_dbs">Method <code>get_dbs</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> get_dbs(@self) -&gt; <span class="kw">Result</span>&lt;~[~<span class="kw">str</span>], MongoErr&gt;</code></pre>
<p>Returns vector of database names.</p>
<h4 id="returns-1">Returns</h4>
<p>vector of database names on success, <code>MongoErr</code> on any failure</p>
<h4 id="failure-types">Failure Types</h4>
<ul>
<li>errors propagated from <code>run_command</code></li>
<li>response from server not in expected form (must contain &quot;databases&quot; field whose value is array of docs containing &quot;name&quot; fields of <code>UString</code>s)</li>
</ul>
<h3 id="method-get_db">Method <code>get_db</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> get_db(@self, db: ~<span class="kw">str</span>) -&gt; DB</code></pre>
<p>Gets the specified <code>DB</code>. Alternative to constructing the <code>DB</code> explicitly (<code>DB::new(db, client)</code>).</p>
<h4 id="arguments">Arguments</h4>
<ul>
<li><code>db</code> - name of <code>DB</code> to get</li>
</ul>
<h4 id="returns-2">Returns</h4>
<p>handle to specified database</p>
<h3 id="method-drop_db">Method <code>drop_db</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> drop_db(@self, db: ~<span class="kw">str</span>) -&gt; <span class="kw">Result</span>&lt;(), MongoErr&gt;</code></pre>
<p>Drops the given database.</p>
<h4 id="arguments-1">Arguments</h4>
<ul>
<li><code>db</code> - name of database to drop</li>
</ul>
<h4 id="returns-3">Returns</h4>
<p>() on success, MongoErr on failure</p>
<h4 id="failure-types-1">Failure Types</h4>
<ul>
<li>anything propagated from run_command</li>
</ul>
<h3 id="method-get_collection">Method <code>get_collection</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> get_collection(@self, db: ~<span class="kw">str</span>, coll: ~<span class="kw">str</span>) -&gt; Collection</code></pre>
<p>Gets the specified <code>Collection</code>. Alternative to constructing the <code>Collection</code> explicitly (<code>Collection::new(db, collection, client)</code>).</p>
<h4 id="arguments-2">Arguments</h4>
<ul>
<li><code>db</code> - database from which to get collection</li>
<li><code>coll</code> - name of <code>Collection</code> to get</li>
</ul>
<h4 id="returns-4">Returns</h4>
<p>handle to specified collection</p>
<h3 id="method-connect">Method <code>connect</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> connect(&amp;<span class="kw">self</span>, server_ip_str: ~<span class="kw">str</span>, server_port: <span class="kw">uint</span>) -&gt;
 <span class="kw">Result</span>&lt;(), MongoErr&gt;</code></pre>
<p>Connects to a single server.</p>
<h4 id="arguments-3">Arguments</h4>
<ul>
<li><code>server_ip_str</code> - string containing IP address of server</li>
<li><code>server_port</code> - port to which to connect</li>
</ul>
<h4 id="returns-5">Returns</h4>
<p>() on success, <code>MongoErr</code> on failure</p>
<h4 id="failure-types-2">Failure Types</h4>
<ul>
<li>already connected</li>
<li>network</li>
</ul>
<h3 id="method-disconnect">Method <code>disconnect</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> disconnect(&amp;<span class="kw">self</span>) -&gt; <span class="kw">Result</span>&lt;(), MongoErr&gt;</code></pre>
<p>Disconnects from server. Simultaneously empties connection cell.</p>
<h4 id="returns-6">Returns</h4>
<p>() on success, <code>MongoErr</code> on failure</p>
<h4 id="failure-types-3">Failure Types</h4>
<ul>
<li>network</li>
</ul>
<h3 id="method-_send_msg">Method <code>_send_msg</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> _send_msg(@self, msg: ~[<span class="kw">u8</span>], wc_pair: (&amp;~<span class="kw">str</span>, <span class="kw">Option</span>&lt;~[WRITE_CONCERN]&gt;),
             read: <span class="kw">bool</span>) -&gt; <span class="kw">Result</span>&lt;<span class="kw">Option</span>&lt;ServerMsg&gt;, MongoErr&gt;</code></pre>
<p>Sends message on connection; if write, checks write concern, and if query, picks up OP_REPLY.</p>
<h4 id="arguments-4">Arguments</h4>
<ul>
<li><code>msg</code> - bytes to send</li>
<li><code>wc</code> - write concern (if applicable)</li>
<li><code>auto_get_reply</code> - whether <code>Client</code> should expect an <code>OP_REPLY</code> from the server</li>
</ul>
<h4 id="returns-7">Returns</h4>
<p>if read operation, <code>OP_REPLY</code> on success, <code>MongoErr</code> on failure; if write operation, <code>None</code> on no last error, <code>MongoErr</code> on last error or network error</p>
<h3 id="method-get_requestid">Method <code>get_requestId</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> get_requestId(&amp;<span class="kw">self</span>) -&gt; <span class="kw">i32</span></code></pre>
<p>Returns first unused requestId.</p>
<h3 id="method-inc_requestid">Method <code>inc_requestId</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> inc_requestId(&amp;<span class="kw">self</span>) -&gt; <span class="kw">i32</span></code></pre>
<p>Increments first unused requestId and returns former value.</p>
<h3 id="method-check_version">Method <code>check_version</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> check_version(@self, ver: ~<span class="kw">str</span>) -&gt; <span class="kw">Result</span>&lt;(), MongoErr&gt;</code></pre>
