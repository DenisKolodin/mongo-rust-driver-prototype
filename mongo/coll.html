<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Module coll</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="rust.css" type="text/css" />
</head>
<body>
<div id="header">
<h1 class="title">Module coll</h1>
</div>
<div class='index'>

<ul>
<li><a href="#enum-mongoindex">Enum <code>MongoIndex</code></a></li>
<li><a href="#struct-collection">Struct <code>Collection</code></a></li>
<li><a href="#implementation-for-mongoindex">Implementation <code>for MongoIndex</code></a></li>
<li><a href="#implementation-for-collection">Implementation <code>for Collection</code></a></li>
</ul>
</div>

<div id="enum-mongoindex" class="section level2">
<h2>Enum <code>MongoIndex</code></h2>
<div id="variants" class="section level4">
<h4>Variants</h4>
<ul>
<li><p><code>MongoIndexName(~str)</code></p></li>
<li><p><code>MongoIndexFields(~[INDEX_FIELD])</code></p></li>
</ul>
</div>
</div>
<div id="struct-collection" class="section level2">
<h2>Struct <code>Collection</code></h2>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">struct</span> Collection {
    db: ~<span class="kw">str</span>,
    name: ~<span class="kw">str</span>,
    <span class="kw">priv</span> client: @Client,
}</code></pre>
</div>
<div id="implementation-for-mongoindex" class="section level2">
<h2>Implementation for <code>MongoIndex</code></h2>
<div id="method-get_name" class="section level3">
<h3>Method <code>get_name</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> get_name(&amp;<span class="kw">self</span>) -&gt; ~<span class="kw">str</span></code></pre>
<p>From either <code>~str</code> or full specification of index, get name.</p>
</div>
</div>
<div id="implementation-for-collection" class="section level2">
<h2>Implementation for <code>Collection</code></h2>
<div id="method-new" class="section level3">
<h3>Method <code>new</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> new(db: ~<span class="kw">str</span>, name: ~<span class="kw">str</span>, client: @Client) -&gt; Collection</code></pre>
<p>Collection constructor for Client, etc. use.</p>
</div>
<div id="method-get_db" class="section level3">
<h3>Method <code>get_db</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> get_db(&amp;<span class="kw">self</span>) -&gt; DB</code></pre>
<p>Get DB containing this Collection.</p>
</div>
<div id="method-insert" class="section level3">
<h3>Method <code>insert</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> insert&lt;U: BsonFormattable&gt;(&amp;<span class="kw">self</span>, doc: U, wc: <span class="kw">Option</span>&lt;~[WRITE_CONCERN]&gt;) -&gt;
 <span class="kw">Result</span>&lt;(), MongoErr&gt;</code></pre>
<p>CRUD ops. Different methods rather than enum of arguments since complexity not decreased with enum (for both users and developers), and CRUD oeprations assumed reasonably stable. INSERT OPS Insert given document with given writeconcern into Collection.</p>
<div id="arguments" class="section level4">
<h4>Arguments</h4>
<ul>
<li><code>doc</code>- BsonFormattable to input</li>
<li><code>wc</code> - write concern with which to insert (None for default of 1, Some for finer specification)</li>
</ul>
</div>
<div id="returns" class="section level4">
<h4>Returns</h4>
<p>() on success, MongoErr on failure</p>
</div>
<div id="failure-types" class="section level4">
<h4>Failure Types</h4>
<ul>
<li>invalid document to insert</li>
<li>network</li>
</ul>
</div>
</div>
<div id="method-insert_batch" class="section level3">
<h3>Method <code>insert_batch</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> insert_batch&lt;U: BsonFormattable&gt;(&amp;<span class="kw">self</span>, docs: ~[U],
                                    flag_array: <span class="kw">Option</span>&lt;~[INSERT_FLAG]&gt;,
                                    option_array: <span class="kw">Option</span>&lt;~[INSERT_OPTION]&gt;,
                                    wc: <span class="kw">Option</span>&lt;~[WRITE_CONCERN]&gt;) -&gt;
 <span class="kw">Result</span>&lt;(), MongoErr&gt;</code></pre>
<p>Insert given batch of documents with given writeconcern and options into Collection.</p>
<div id="arguments-1" class="section level4">
<h4>Arguments</h4>
<ul>
<li><code>docs</code>- array of BsonFormattable to input</li>
<li><code>flag_array</code> - <code>CONT_ON_ERR</code></li>
<li><code>option_array</code> - [none yet]</li>
<li><code>wc</code> - write concern with which to insert (None for default of 1, Some for finer specification)</li>
</ul>
</div>
<div id="returns-1" class="section level4">
<h4>Returns</h4>
<p>() on success, MongoErr on failure</p>
</div>
<div id="failure-types-1" class="section level4">
<h4>Failure Types</h4>
<ul>
<li>invalid document to insert (e.g. not proper format or duplicate <code>_id</code>)</li>
<li>network</li>
</ul>
</div>
</div>
<div id="method-save" class="section level3">
<h3>Method <code>save</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> save&lt;U: BsonFormattable&gt;(&amp;<span class="kw">self</span>, doc: U, wc: <span class="kw">Option</span>&lt;~[WRITE_CONCERN]&gt;) -&gt;
 <span class="kw">Result</span>&lt;(), MongoErr&gt;</code></pre>
</div>
<div id="method-update" class="section level3">
<h3>Method <code>update</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> update(&amp;<span class="kw">self</span>, query: QuerySpec, update_spec: QuerySpec,
          flag_array: <span class="kw">Option</span>&lt;~[UPDATE_FLAG]&gt;,
          option_array: <span class="kw">Option</span>&lt;~[UPDATE_OPTION]&gt;,
          wc: <span class="kw">Option</span>&lt;~[WRITE_CONCERN]&gt;) -&gt; <span class="kw">Result</span>&lt;(), MongoErr&gt;</code></pre>
<p>UPDATE OPS Update documents satisfying given query with given update specification and write concern.</p>
<div id="arguments-2" class="section level4">
<h4>Arguments</h4>
<ul>
<li><code>query</code> - <code>SpecNotation(~str)</code> or <code>SpecObj(BsonDocument)</code> specifying documents to update</li>
<li><code>update_spec</code> - <code>SpecNotation(~str)</code> or <code>SpecObj(BsonDocument)</code> specifying update to documents</li>
<li><code>flag_array</code> - <code>UPSERT</code>, <code>MULTI</code></li>
<li><code>option_array</code> - [nothing yet]</li>
<li><code>wc</code> - write concern with which to update documents</li>
</ul>
</div>
<div id="returns-2" class="section level4">
<h4>Returns</h4>
<p>() on success, MongoErr on failure</p>
</div>
<div id="failure-types-2" class="section level4">
<h4>Failure Types</h4>
<ul>
<li>invalid query or update specification</li>
<li>getLastError</li>
<li>network</li>
</ul>
</div>
</div>
<div id="method-find" class="section level3">
<h3>Method <code>find</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> find(&amp;<span class="kw">self</span>, query: <span class="kw">Option</span>&lt;QuerySpec&gt;, proj: <span class="kw">Option</span>&lt;QuerySpec&gt;,
        flag_array: <span class="kw">Option</span>&lt;~[QUERY_FLAG]&gt;) -&gt; <span class="kw">Result</span>&lt;Cursor, MongoErr&gt;</code></pre>
<p>Returns Cursor over given projection from queried documents.</p>
<div id="arguments-3" class="section level4">
<h4>Arguments</h4>
<ul>
<li><code>query</code> - optional <code>SpecNotation(~str)</code> or <code>SpecObj(BsonDocument)</code> specifying documents to query</li>
<li><code>proj</code> - optioal <code>SpecNotation(~str)</code> or <code>SpecObj(BsonDocument)</code> specifying projection from queried documents</li>
<li><code>flag_array</code> - optional, <code>CUR_TAILABLE</code>, <code>SLAVE_OK</code>, <code>OPLOG_REPLAY</code>, <code>NO_CUR_TIMEOUT</code>, <code>AWAIT_DATA</code>, <code>EXHAUST</code>, <code>PARTIAL</code></li>
</ul>
</div>
<div id="returns-3" class="section level4">
<h4>Returns</h4>
<p>initialized (unqueried) Cursor on success, MongoErr on failure</p>
</div>
</div>
<div id="method-find_one" class="section level3">
<h3>Method <code>find_one</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> find_one(&amp;<span class="kw">self</span>, query: <span class="kw">Option</span>&lt;QuerySpec&gt;, proj: <span class="kw">Option</span>&lt;QuerySpec&gt;,
            flag_array: <span class="kw">Option</span>&lt;~[QUERY_FLAG]&gt;) -&gt;
 <span class="kw">Result</span>&lt;~BsonDocument, MongoErr&gt;</code></pre>
<p>Returns pointer to first Bson from queried documents.</p>
<div id="arguments-4" class="section level4">
<h4>Arguments</h4>
<ul>
<li><code>query</code> - optional <code>SpecNotation(~str)</code> or <code>SpecObj(BsonDocument)</code> specifying documents to query</li>
<li><code>proj</code> - optional <code>SpecNotation(~str)</code> or <code>SpecObj(BsonDocument)</code> specifying projection from queried documents</li>
<li><code>flag_array</code> - optional, <code>CUR_TAILABLE</code>, <code>SLAVE_OK</code>, <code>OPLOG_REPLAY</code>, <code>NO_CUR_TIMEOUT</code>, <code>AWAIT_DATA</code>, <code>EXHAUST</code>, <code>PARTIAL</code></li>
</ul>
</div>
<div id="returns-4" class="section level4">
<h4>Returns</h4>
<p>~BsonDocument of first result on success, MongoErr on failure</p>
</div>
</div>
<div id="method-remove" class="section level3">
<h3>Method <code>remove</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> remove(&amp;<span class="kw">self</span>, query: <span class="kw">Option</span>&lt;QuerySpec&gt;, flag_array: <span class="kw">Option</span>&lt;~[DELETE_FLAG]&gt;,
          option_array: <span class="kw">Option</span>&lt;~[DELETE_OPTION]&gt;,
          wc: <span class="kw">Option</span>&lt;~[WRITE_CONCERN]&gt;) -&gt; <span class="kw">Result</span>&lt;(), MongoErr&gt;</code></pre>
<p>Remove specified documents from collection.</p>
<div id="arguments-5" class="section level4">
<h4>Arguments</h4>
<ul>
<li><code>query</code> - optional <code>SpecNotation(~str)</code> or <code>SpecObj(BsonDocument)</code> specifying documents to query</li>
<li><code>flag_array</code> - optional, <code>CUR_TAILABLE</code>, <code>SLAVE_OK</code>, <code>OPLOG_REPLAY</code>, <code>NO_CUR_TIMEOUT</code>, <code>AWAIT_DATA</code>, <code>EXHAUST</code>, <code>PARTIAL</code></li>
<li><code>option_array</code> - [nothing yet]</li>
<li><code>wc</code> - write concern with which to perform remove</li>
</ul>
</div>
<div id="returns-5" class="section level4">
<h4>Returns</h4>
<p>() on success, MongoErr on failure</p>
</div>
</div>
<div id="method-create_index" class="section level3">
<h3>Method <code>create_index</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> create_index(&amp;<span class="kw">self</span>, index_arr: ~[INDEX_FIELD],
                flag_array: <span class="kw">Option</span>&lt;~[INDEX_FLAG]&gt;,
                option_array: <span class="kw">Option</span>&lt;~[INDEX_OPTION]&gt;) -&gt;
 <span class="kw">Result</span>&lt;MongoIndex, MongoErr&gt;</code></pre>
<p>INDICES (or &quot;Indexes&quot;) Create index by specifying a vector of the different elements that can form an index (e.g. (field,order) pairs, geographical options, etc.)</p>
<div id="arguments-6" class="section level4">
<h4>Arguments</h4>
<ul>
<li><code>index_arr</code> - vector of index elements (NORMAL(vector of (field, order) pairs), HASHED(field), GEOSPATIAL(field, type))</li>
<li><code>flag_array</code> - optional vector of index-creating flags: BACKGROUND, UNIQUE, DROP_DUPS, SPARSE</li>
<li><code>option_array</code> - optional vector of index-creating options: INDEX_NAME(name), EXPIRE_AFTER_SEC(nsecs)</li>
</ul>
</div>
<div id="returns-6" class="section level4">
<h4>Returns</h4>
<p>name of index as MongoIndexName (in enum MongoIndex) on success, MongoErr on failure</p>
</div>
</div>
<div id="method-ensure_index" class="section level3">
<h3>Method <code>ensure_index</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> ensure_index(&amp;<span class="kw">self</span>, index_arr: ~[INDEX_FIELD],
                flag_array: <span class="kw">Option</span>&lt;~[INDEX_FLAG]&gt;,
                option_array: <span class="kw">Option</span>&lt;~[INDEX_OPTION]&gt;) -&gt;
 <span class="kw">Result</span>&lt;MongoIndex, MongoErr&gt;</code></pre>
</div>
<div id="method-drop_index" class="section level3">
<h3>Method <code>drop_index</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> drop_index(&amp;<span class="kw">self</span>, index: MongoIndex) -&gt; <span class="kw">Result</span>&lt;(), MongoErr&gt;</code></pre>
<p>Drops specified index.</p>
<div id="arguments-7" class="section level4">
<h4>Arguments</h4>
<ul>
<li><code>index</code> - MongoIndex to drop specified either by explicit name or fields</li>
</ul>
</div>
<div id="returns-7" class="section level4">
<h4>Returns</h4>
<p>() on success, MongoErr on failure</p>
</div>
</div>
<div id="method-validate" class="section level3">
<h3>Method <code>validate</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> validate(&amp;<span class="kw">self</span>, full: <span class="kw">bool</span>, scandata: <span class="kw">bool</span>) -&gt;
 <span class="kw">Result</span>&lt;~BsonDocument, MongoErr&gt;</code></pre>
<p>Validate a collection.</p>
</div>
</div>
</body>
</html>
