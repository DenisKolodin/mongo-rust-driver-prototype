<div class='index'>

<ul>
<li><a href="#enum-mongoindex">Enum <code>MongoIndex</code></a></li>
<li><a href="#struct-collection">Struct <code>Collection</code></a></li>
<li><a href="#implementation-for-mongoindex">Implementation <code>for MongoIndex</code></a></li>
<li><a href="#implementation-for-collection">Implementation <code>for Collection</code></a></li>
</ul>
</div>

<h2 id="enum-mongoindex">Enum <code>MongoIndex</code></h2>
<h4 id="variants">Variants</h4>
<ul>
<li><p><code>MongoIndexName(~str)</code></p></li>
<li><p><code>MongoIndexFields(~[INDEX_FIELD])</code></p></li>
</ul>
<h2 id="struct-collection">Struct <code>Collection</code></h2>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">struct</span> Collection {
    db: ~<span class="kw">str</span>,
    name: ~<span class="kw">str</span>,
    <span class="kw">priv</span> client: @Client,
}</code></pre>
<h2 id="implementation-for-mongoindex">Implementation for <code>MongoIndex</code></h2>
<h3 id="method-get_name">Method <code>get_name</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> get_name(&amp;<span class="kw">self</span>) -&gt; ~<span class="kw">str</span></code></pre>
<p>From either <code>~str</code> or full specification of index, gets name.</p>
<h4 id="returns">Returns</h4>
<p>name of index (string passed in if <code>MongoIndexName</code> passed), default index name if <code>MongoIndexFields</code> passed)</p>
<h2 id="implementation-for-collection">Implementation for <code>Collection</code></h2>
<p>Having created a <code>Client</code> and connected as desired to a server or cluster, users may interact with collections by creating <code>Collection</code> handles to those collections.</p>
<h3 id="method-new">Method <code>new</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> new(db: &amp;<span class="kw">str</span>, name: &amp;<span class="kw">str</span>, client: @Client) -&gt; Collection</code></pre>
<p>Creates a new handle to the given collection. Alternative to <code>client.get_collection(db, collection)</code>.</p>
<h4 id="arguments">Arguments</h4>
<ul>
<li><code>db</code> - name of database</li>
<li><code>coll</code> - name of collection to get</li>
<li><code>client</code> - name of client associated with <code>Collection</code></li>
</ul>
<h4 id="returns-1">Returns</h4>
<p>handle to given collection</p>
<h3 id="method-get_db">Method <code>get_db</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> get_db(&amp;<span class="kw">self</span>) -&gt; DB</code></pre>
<p>Gets <code>DB</code> containing this <code>Collection</code>.</p>
<h4 id="returns-2">Returns</h4>
<p>handle to database containing this <code>Collection</code></p>
<h3 id="method-to_capped">Method <code>to_capped</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> to_capped(&amp;<span class="kw">self</span>, options: ~[COLLECTION_OPTION]) -&gt; <span class="kw">Result</span>&lt;(), MongoErr&gt;</code></pre>
<p>Converts this collection to a capped collection.</p>
<h4 id="arguments-1">Arguments</h4>
<ul>
<li><code>options</code> - array of options with which to create capped collection</li>
</ul>
<h4 id="returns-3">Returns</h4>
<p>() on success, <code>MongoErr</code> on failure</p>
<h3 id="method-insert">Method <code>insert</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> insert&lt;U: BsonFormattable&gt;(&amp;<span class="kw">self</span>, doc: U, wc: <span class="kw">Option</span>&lt;~[WRITE_CONCERN]&gt;) -&gt;
 <span class="kw">Result</span>&lt;(), MongoErr&gt;</code></pre>
<p>CRUD ops.</p>
<p>Different methods rather than enum of arguments since complexity not decreased with enum (for both users and developers), and CRUD oeprations assumed reasonably stable.</p>
<p>Moreover, basic operations still do take enums for flexibility; easy to wrap for syntactic sugar. INSERT OPS Inserts given document with given write concern into collection.</p>
<h4 id="arguments-2">Arguments</h4>
<ul>
<li><code>doc</code>- <code>BsonFormattable</code> to input</li>
<li><code>wc</code> - write concern with which to insert (<code>None</code> for default of 1, <code>Some</code> for finer specification)</li>
</ul>
<h4 id="returns-4">Returns</h4>
<p>() on success, <code>MongoErr</code> on failure</p>
<h4 id="failure-types">Failure Types</h4>
<ul>
<li>invalid document to insert</li>
<li>network</li>
</ul>
<h3 id="method-insert_batch">Method <code>insert_batch</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> insert_batch&lt;U: BsonFormattable&gt;(&amp;<span class="kw">self</span>, docs: ~[U],
                                    flag_array: <span class="kw">Option</span>&lt;~[INSERT_FLAG]&gt;,
                                    option_array: <span class="kw">Option</span>&lt;~[INSERT_OPTION]&gt;,
                                    wc: <span class="kw">Option</span>&lt;~[WRITE_CONCERN]&gt;) -&gt;
 <span class="kw">Result</span>&lt;(), MongoErr&gt;</code></pre>
<p>Inserts given batch of documents with given write concern and options into collection.</p>
<h4 id="arguments-3">Arguments</h4>
<ul>
<li><code>docs</code>- array of <code>BsonFormattable</code>s to input</li>
<li><code>flag_array</code> - <code>CONT_ON_ERR</code></li>
<li><code>option_array</code> - [none yet]</li>
<li><code>wc</code> - write concern with which to insert (<code>None</code> for default of 1, <code>Some</code> for finer specification)</li>
</ul>
<h4 id="returns-5">Returns</h4>
<p>() on success, <code>MongoErr</code> on failure</p>
<h4 id="failure-types-1">Failure Types</h4>
<ul>
<li>invalid document to insert (e.g. not proper format or duplicate <code>_id</code>)</li>
<li>network</li>
</ul>
<h3 id="method-save">Method <code>save</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> save&lt;U: BsonFormattable&gt;(&amp;<span class="kw">self</span>, doc: U, wc: <span class="kw">Option</span>&lt;~[WRITE_CONCERN]&gt;) -&gt;
 <span class="kw">Result</span>&lt;(), MongoErr&gt;</code></pre>
<h3 id="method-update">Method <code>update</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> update(&amp;<span class="kw">self</span>, query: QuerySpec, update_spec: QuerySpec,
          flag_array: <span class="kw">Option</span>&lt;~[UPDATE_FLAG]&gt;,
          option_array: <span class="kw">Option</span>&lt;~[UPDATE_OPTION]&gt;,
          wc: <span class="kw">Option</span>&lt;~[WRITE_CONCERN]&gt;) -&gt; <span class="kw">Result</span>&lt;(), MongoErr&gt;</code></pre>
<p>UPDATE OPS Updates documents satisfying given query with given update specification and write concern.</p>
<h4 id="arguments-4">Arguments</h4>
<ul>
<li><code>query</code> - <code>SpecNotation(~str)</code> or <code>SpecObj(BsonDocument)</code> specifying documents to update</li>
<li><code>update_spec</code> - <code>SpecNotation(~str)</code> or <code>SpecObj(BsonDocument)</code> specifying update to documents</li>
<li><code>flag_array</code> - <code>UPSERT</code>, <code>MULTI</code></li>
<li><code>option_array</code> - [nothing yet]</li>
<li><code>wc</code> - write concern with which to update documents</li>
</ul>
<h4 id="returns-6">Returns</h4>
<p>() on success, <code>MongoErr</code> on failure</p>
<h4 id="failure-types-2">Failure Types</h4>
<ul>
<li>invalid query or update specification</li>
<li>getLastError</li>
<li>network</li>
</ul>
<h3 id="method-find">Method <code>find</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> find(&amp;<span class="kw">self</span>, query: <span class="kw">Option</span>&lt;QuerySpec&gt;, proj: <span class="kw">Option</span>&lt;QuerySpec&gt;,
        flag_array: <span class="kw">Option</span>&lt;~[QUERY_FLAG]&gt;) -&gt; <span class="kw">Result</span>&lt;Cursor, MongoErr&gt;</code></pre>
<p>Returns Cursor over given projection from queried documents.</p>
<h4 id="arguments-5">Arguments</h4>
<ul>
<li><code>query</code> - optional <code>SpecNotation(~str)</code> or <code>SpecObj(BsonDocument)</code> specifying documents to query</li>
<li><code>proj</code> - optioal <code>SpecNotation(~str)</code> or <code>SpecObj(BsonDocument)</code> specifying projection from queried documents</li>
<li><code>flag_array</code> - optional, <code>CUR_TAILABLE</code>, <code>SLAVE_OK</code>, <code>OPLOG_REPLAY</code>, <code>NO_CUR_TIMEOUT</code>, <code>AWAIT_DATA</code>, <code>EXHAUST</code>, <code>PARTIAL</code></li>
</ul>
<h4 id="returns-7">Returns</h4>
<p>initialized (unqueried) Cursor on success, <code>MongoErr</code> on failure</p>
<h3 id="method-find_one">Method <code>find_one</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> find_one(&amp;<span class="kw">self</span>, query: <span class="kw">Option</span>&lt;QuerySpec&gt;, proj: <span class="kw">Option</span>&lt;QuerySpec&gt;,
            flag_array: <span class="kw">Option</span>&lt;~[QUERY_FLAG]&gt;) -&gt;
 <span class="kw">Result</span>&lt;~BsonDocument, MongoErr&gt;</code></pre>
<p>Returns pointer to first Bson from queried documents.</p>
<h4 id="arguments-6">Arguments</h4>
<ul>
<li><code>query</code> - optional <code>SpecNotation(~str)</code> or <code>SpecObj(BsonDocument)</code> specifying documents to query</li>
<li><code>proj</code> - optional <code>SpecNotation(~str)</code> or <code>SpecObj(BsonDocument)</code> specifying projection from queried documents</li>
<li><code>flag_array</code> - optional, <code>CUR_TAILABLE</code>, <code>SLAVE_OK</code>, <code>OPLOG_REPLAY</code>, <code>NO_CUR_TIMEOUT</code>, <code>AWAIT_DATA</code>, <code>EXHAUST</code>, <code>PARTIAL</code></li>
</ul>
<h4 id="returns-8">Returns</h4>
<p>~BsonDocument of first result on success, MongoErr on failure</p>
<h3 id="method-remove">Method <code>remove</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> remove(&amp;<span class="kw">self</span>, query: <span class="kw">Option</span>&lt;QuerySpec&gt;, flag_array: <span class="kw">Option</span>&lt;~[DELETE_FLAG]&gt;,
          option_array: <span class="kw">Option</span>&lt;~[DELETE_OPTION]&gt;,
          wc: <span class="kw">Option</span>&lt;~[WRITE_CONCERN]&gt;) -&gt; <span class="kw">Result</span>&lt;(), MongoErr&gt;</code></pre>
<p>Removes specified documents from collection.</p>
<h4 id="arguments-7">Arguments</h4>
<ul>
<li><code>query</code> - optional <code>SpecNotation(~str)</code> or <code>SpecObj(BsonDocument)</code> specifying documents to query</li>
<li><code>flag_array</code> - optional, <code>CUR_TAILABLE</code>, <code>SLAVE_OK</code>, <code>OPLOG_REPLAY</code>, <code>NO_CUR_TIMEOUT</code>, <code>AWAIT_DATA</code>, <code>EXHAUST</code>, <code>PARTIAL</code></li>
<li><code>option_array</code> - [nothing yet]</li>
<li><code>wc</code> - write concern with which to perform remove</li>
</ul>
<h4 id="returns-9">Returns</h4>
<p>() on success, <code>MongoErr</code> on failure</p>
<h3 id="method-create_index">Method <code>create_index</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> create_index(&amp;<span class="kw">self</span>, index_arr: ~[INDEX_FIELD],
                flag_array: <span class="kw">Option</span>&lt;~[INDEX_FLAG]&gt;,
                option_array: <span class="kw">Option</span>&lt;~[INDEX_OPTION]&gt;) -&gt;
 <span class="kw">Result</span>&lt;MongoIndex, MongoErr&gt;</code></pre>
<p>INDICES (or &quot;Indexes&quot;) Creates index by specifying a vector of the different elements that can form an index (e.g. (field,order) pairs, geographical options, etc.)</p>
<h4 id="arguments-8">Arguments</h4>
<ul>
<li><code>index_arr</code> - vector of index elements (<code>NORMAL(vector of (field, order) pairs)</code>, <code>HASHED(field)</code>, <code>GEOSPATIAL(field, type)</code>, `GEOHAYSTACK(loc, field, bucket)')</li>
<li><code>flag_array</code> - optional vector of index-creating flags: <code>BACKGROUND</code>, <code>UNIQUE</code>, <code>DROP_DUPS</code>, <code>SPARSE</code></li>
<li><code>option_array</code> - optional vector of index-creating options: <code>INDEX_NAME(name)</code>, <code>EXPIRE_AFTER_SEC(nsecs)</code>, <code>VERS(version no)</code></li>
</ul>
<h4 id="returns-10">Returns</h4>
<p>name of index as <code>MongoIndexName</code> (in enum <code>MongoIndex</code>) on success, <code>MongoErr</code> on failure</p>
<h3 id="method-ensure_index">Method <code>ensure_index</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> ensure_index(&amp;<span class="kw">self</span>, index_arr: ~[INDEX_FIELD],
                flag_array: <span class="kw">Option</span>&lt;~[INDEX_FLAG]&gt;,
                option_array: <span class="kw">Option</span>&lt;~[INDEX_OPTION]&gt;) -&gt;
 <span class="kw">Result</span>&lt;MongoIndex, MongoErr&gt;</code></pre>
<h3 id="method-get_indexes">Method <code>get_indexes</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> get_indexes(&amp;<span class="kw">self</span>) -&gt; <span class="kw">Result</span>&lt;~[~<span class="kw">str</span>], MongoErr&gt;</code></pre>
<h3 id="method-drop_index">Method <code>drop_index</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> drop_index(&amp;<span class="kw">self</span>, index: MongoIndex) -&gt; <span class="kw">Result</span>&lt;(), MongoErr&gt;</code></pre>
<p>Drops specified index.</p>
<h4 id="arguments-9">Arguments</h4>
<ul>
<li><code>index</code> - <code>MongoIndex</code> to drop specified either by explicit name or fields</li>
</ul>
<h4 id="returns-11">Returns</h4>
<p>() on success, <code>MongoErr</code> on failure</p>
<h3 id="method-validate">Method <code>validate</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> validate(&amp;<span class="kw">self</span>, full: <span class="kw">bool</span>, scandata: <span class="kw">bool</span>) -&gt;
 <span class="kw">Result</span>&lt;~BsonDocument, MongoErr&gt;</code></pre>
<p>Validate a collection.</p>
