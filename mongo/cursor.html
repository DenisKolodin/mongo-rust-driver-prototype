<div class='index'>

<ul>
<li><a href="#struct-cursor">Struct <code>Cursor</code></a> - Structure representing a cursor</li>
<li><a href="#implementation-of-iteratorbsondocument-for-cursor">Implementation <code>of Iterator&lt;~BsonDocument&gt; for Cursor</code></a> - Iterator implementation, opens access to powerful functions like collect, advance, map, etc.</li>
<li><a href="#implementation-for-cursor">Implementation <code>for Cursor</code></a> - Cursor API</li>
</ul>
</div>

<h2 id="struct-cursor">Struct <code>Cursor</code></h2>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">struct</span> Cursor {
    <span class="kw">priv</span> id: <span class="kw">Option</span>&lt;<span class="kw">i64</span>&gt;,
    <span class="kw">priv</span> db: ~<span class="kw">str</span>,
    <span class="kw">priv</span> coll: ~<span class="kw">str</span>,
    <span class="kw">priv</span> client: @Client,
    flags: <span class="kw">i32</span>,
    batch_size: <span class="kw">i32</span>,
    query_spec: BsonDocument,
    open: <span class="kw">bool</span>,
    iter_err: <span class="kw">Option</span>&lt;MongoErr&gt;,
    <span class="kw">priv</span> retrieved: <span class="kw">i32</span>,
    <span class="kw">priv</span> proj_spec: <span class="kw">Option</span>&lt;BsonDocument&gt;,
    <span class="kw">priv</span> skip: <span class="kw">i32</span>,
    <span class="kw">priv</span> limit: <span class="kw">i32</span>,
    <span class="kw">priv</span> data: ~[~BsonDocument],
    <span class="kw">priv</span> done: Cell&lt;<span class="kw">bool</span>&gt;,
}</code></pre>
<p>Structure representing a cursor</p>
<h2 id="implementation-of-iteratorbsondocument-for-cursor">Implementation of <code>Iterator&lt;~BsonDocument&gt;</code> for <code>Cursor</code></h2>
<p>Iterator implementation, opens access to powerful functions like collect, advance, map, etc.</p>
<h3 id="method-next">Method <code>next</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> next(&amp;<span class="kw">mut</span> <span class="kw">self</span>) -&gt; <span class="kw">Option</span>&lt;~BsonDocument&gt;</code></pre>
<p>Returns pointer to next <code>BsonDocument</code>.</p>
<p>Pointers passed for greater memory flexibility. Any errors are stored in <code>Cursor</code>'s <code>iter_err</code> field.</p>
<h4 id="returns">Returns</h4>
<p><code>Some(~BsonDocument)</code> if there are more BsonDocuments, <code>None</code> otherwise</p>
<h2 id="implementation-for-cursor">Implementation for <code>Cursor</code></h2>
<p>Cursor API</p>
<h3 id="method-new">Method <code>new</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> new(query: BsonDocument, proj: <span class="kw">Option</span>&lt;BsonDocument&gt;,
       collection: &amp;Collection, client: @Client, flags: <span class="kw">i32</span>) -&gt; Cursor</code></pre>
<p>Initialize cursor with query, projection, collection, flags, and skip and limit, but don't query yet (i.e. constructed cursors are empty).</p>
<h4 id="arguments">Arguments</h4>
<ul>
<li><code>query</code> - query associated with this <code>Cursor</code></li>
<li><code>proj</code> - projection of query associated with this <code>Cursor</code></li>
<li><code>collection</code> - <code>Collection</code> associated with this <code>Cursor</code>; passed for convenience</li>
<li><code>client</code> - <code>Client</code> associated with this <code>Cursor</code>,</li>
<li><code>flags</code> - <code>CUR_TAILABLE</code>, <code>SLAVE_OK</code>, <code>OPLOG_REPLAY</code>, <code>NO_CUR_TIMEOUT</code>, <code>AWAIT_DATA</code>, <code>EXHAUST</code>, <code>PARTIAL</code></li>
</ul>
<h4 id="returns-1">Returns</h4>
<p><code>Cursor</code></p>
<h3 id="method-cursor_skip">Method <code>cursor_skip</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> cursor_skip(&amp;<span class="kw">mut</span> <span class="kw">self</span>, skip: <span class="kw">i32</span>) -&gt; <span class="kw">Result</span>&lt;(), MongoErr&gt;</code></pre>
<p>CURSOR OPTIONS (must be specified pre-querying) Skips specified amount before starting to iterate.</p>
<h4 id="arguments-1">Arguments</h4>
<ul>
<li><code>skip</code> - amount to skip</li>
</ul>
<h4 id="returns-2">Returns</h4>
<p>() on success, <code>MongoErr</code> on failure</p>
<h4 id="failure-types">Failure Types</h4>
<ul>
<li><code>Cursor</code> already iterated over</li>
</ul>
<h3 id="method-cursor_limit">Method <code>cursor_limit</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> cursor_limit(&amp;<span class="kw">mut</span> <span class="kw">self</span>, limit: <span class="kw">i32</span>) -&gt; <span class="kw">Result</span>&lt;(), MongoErr&gt;</code></pre>
<p>Limits amount to return from <code>Cursor</code>.</p>
<h4 id="arguments-2">Arguments</h4>
<ul>
<li><code>limit</code> - total amount to return</li>
</ul>
<h4 id="returns-3">Returns</h4>
<p>() on success, <code>MongoErr</code> on failure</p>
<h4 id="failure-types-1">Failure Types</h4>
<ul>
<li><code>Cursor</code> already iterated over</li>
</ul>
<h3 id="method-explain">Method <code>explain</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> explain(&amp;<span class="kw">mut</span> <span class="kw">self</span>) -&gt; <span class="kw">Result</span>&lt;~BsonDocument, MongoErr&gt;</code></pre>
<p>QUERY MODIFICATIONS Explains the query. Copies the <code>Cursor</code> and runs the query to gather information. Returns query as <code>~BsonDocument</code> to ease searching for specific fields, etc.</p>
<h4 id="returns-4">Returns</h4>
<p><code>~BsonDocument</code> explaining query on success, <code>MongoErr</code> on failure</p>
<h3 id="method-hint">Method <code>hint</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> hint(&amp;<span class="kw">mut</span> <span class="kw">self</span>, index: MongoIndex)</code></pre>
<p>Hints an index (name or fields+order) to use while querying.</p>
<h4 id="arguments-3">Arguments</h4>
<ul>
<li><code>index</code> - <code>MongoIndexName(name)</code> of index to use (if named), <code>MongoIndexFields(~[INDEX_FIELD])</code> to fully specify index from scratch</li>
</ul>
<h3 id="method-sort">Method <code>sort</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> sort(&amp;<span class="kw">mut</span> <span class="kw">self</span>, orderby: INDEX_FIELD) -&gt; <span class="kw">Result</span>&lt;(), MongoErr&gt;</code></pre>
<p>Sorts results from <code>Cursor</code> given fields and their direction.</p>
<h4 id="arguments-4">Arguments</h4>
<ul>
<li><code>orderby</code> - <code>NORMAL(~[(field, direction)])</code> where <code>field</code>s are <code>~str</code> and <code>direction</code> are <code>ASC</code> or <code>DESC</code></li>
</ul>
<h4 id="returns-5">Returns</h4>
<p>() on success, MongoErr on failure</p>
<h4 id="failure-types-2">Failure Types</h4>
<ul>
<li>invalid sorting specification (<code>orderby</code>)</li>
</ul>
<h3 id="method-add_flags">Method <code>add_flags</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> add_flags(&amp;<span class="kw">mut</span> <span class="kw">self</span>, flags: ~[QUERY_FLAG])</code></pre>
<p>Adds flags to Cursor.</p>
<h4 id="arguments-5">Arguments</h4>
<ul>
<li><code>flags</code> - array of <code>QUERY_FLAGS</code> (specified above), each of which to add</li>
</ul>
<h3 id="method-remove_flags">Method <code>remove_flags</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> remove_flags(&amp;<span class="kw">mut</span> <span class="kw">self</span>, flags: ~[QUERY_FLAG])</code></pre>
<p>Removes flags from Cursor.</p>
<h4 id="arguments-6">Arguments</h4>
<ul>
<li><code>flags</code> - array of <code>QUERY_FLAGS</code> (specified above), each of which to remove</li>
</ul>
<h3 id="method-batch_size">Method <code>batch_size</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> batch_size(&amp;<span class="kw">mut</span> <span class="kw">self</span>, sz: <span class="kw">i32</span>)</code></pre>
<p>Modifies size of next batch to fetch on <code>Cursor</code> refresh.</p>
<h4 id="arguments-7">Arguments</h4>
<ul>
<li><code>sz</code> - size of next batch to fetch on <code>Cursor</code> refresh (<code>QUERY</code> or <code>GET_MORE</code>)</li>
</ul>
<h3 id="method-has_next">Method <code>has_next</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> has_next(&amp;<span class="kw">mut</span> <span class="kw">self</span>) -&gt; <span class="kw">bool</span></code></pre>
<p>OTHER USEFUL FUNCTIONS Returns whether Cursor has a next <code>~BsonDocument</code>. Considers the last element of a <code>Cursor</code> to be <code>None</code>, hence returns <code>true</code> at edge case when <code>Cursor</code> exhausted naturally.</p>
<h3 id="method-close">Method <code>close</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> close(&amp;<span class="kw">mut</span> <span class="kw">self</span>) -&gt; <span class="kw">Result</span>&lt;(), MongoErr&gt;</code></pre>
<p>Closes cursor by sending OP_KILL_CURSORS message.</p>
<h4 id="returns-6">Returns</h4>
<p>() on success, <code>MongoErr</code> on failure</p>
<h3 id="method-is_dead">Method <code>is_dead</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> is_dead(&amp;<span class="kw">self</span>) -&gt; <span class="kw">bool</span></code></pre>
<p>Returns whether this <code>Cursor</code> is dead, i.e. has ID of 0.</p>
<h4 id="returns-7">Returns</h4>
<p>whether this <code>Cursor</code> is dead and can no longer be queried</p>
