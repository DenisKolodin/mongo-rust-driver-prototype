<div class='index'>

<ul>
<li><a href="#enum-document">Enum <code>Document</code></a> - Algebraic data type representing the BSON AST</li>
<li><a href="#struct-bsondocencoder">Struct <code>BsonDocEncoder</code></a> - serialize::Encoder object for Bson</li>
<li><a href="#struct-bsondocument">Struct <code>BsonDocument</code></a> - The type of a complete BSON document</li>
<li><a href="#implementation-of-stdcmpeq-for-document">Implementation <code>of ::std::cmp::Eq for Document</code></a> - Automatically derived.</li>
<li><a href="#implementation-of-stdcloneclone-for-document">Implementation <code>of ::std::clone::Clone for Document</code></a> - Automatically derived.</li>
<li><a href="#implementation-for-objidfactory">Implementation <code>for ObjIdFactory</code></a></li>
<li><a href="#implementation-of-stdcmpeq-for-bsondocument">Implementation <code>of ::std::cmp::Eq for BsonDocument</code></a> - Automatically derived.</li>
<li><a href="#implementation-of-clone-for-bsondocument">Implementation <code>of Clone for BsonDocument</code></a></li>
<li><a href="#implementation-of-encoder-for-bsondocencoder">Implementation <code>of Encoder for BsonDocEncoder</code></a> - serialize::Encoder implementation.</li>
<li><a href="#implementation-of-encodablee-for-bsondocument-where-e-encoder">Implementation <code>of Encodable&lt;E&gt; for BsonDocument where &lt;E: Encoder&gt;</code></a> - Light wrapper around a typical Map implementation.</li>
<li><a href="#implementation-of-encodablee-for-document-where-e-encoder">Implementation <code>of Encodable&lt;E&gt; for Document where &lt;E: Encoder&gt;</code></a> - Encodable implementation for Document.</li>
<li><a href="#implementation-of-tostr-for-bsondocument">Implementation <code>of ToStr for BsonDocument</code></a></li>
<li><a href="#implementation-for-bsondocument-where-self">Implementation <code>for BsonDocument where &lt;'self&gt;</code></a></li>
<li><a href="#implementation-for-document">Implementation <code>for Document</code></a> - Methods on documents.</li>
<li><a href="#implementation-of-tostr-for-document">Implementation <code>of ToStr for Document</code></a></li>
</ul>
</div>

<h2 id="enum-document">Enum <code>Document</code></h2>
<p>Algebraic data type representing the BSON AST. BsonDocument maps string keys to this type. This can be converted back and forth from BsonDocument by using the Embedded variant.</p>
<h4 id="variants">Variants</h4>
<ul>
<li><p><code>Double(f64)</code></p></li>
<li><p><code>UString(~str)</code></p></li>
<li><p><code>Embedded(~BsonDocument)</code></p></li>
<li><p><code>Array(~BsonDocument)</code></p></li>
<li><p><code>Binary(u8, ~[u8])</code></p></li>
<li><p><code>ObjectId(~[u8])</code></p></li>
<li><p><code>Bool(bool)</code></p></li>
<li><p><code>UTCDate(i64)</code></p></li>
<li><p><code>Null</code></p></li>
<li><p><code>Regex(~str, ~str)</code></p></li>
<li><p><code>JScript(~str)</code></p></li>
<li><p><code>JScriptWithScope(~str, ~BsonDocument)</code></p></li>
<li><p><code>Int32(i32)</code></p></li>
<li><p><code>Timestamp(u32, u32)</code></p></li>
<li><p><code>Int64(i64)</code></p></li>
<li><p><code>MinKey</code></p></li>
<li><p><code>MaxKey</code></p></li>
</ul>
<h2 id="struct-bsondocencoder">Struct <code>BsonDocEncoder</code></h2>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">struct</span> BsonDocEncoder {
    <span class="kw">priv</span> buf: ~[<span class="kw">u8</span>],
}</code></pre>
<p>serialize::Encoder object for Bson. After encoding has been done with an Encoder instance, encoder.buf will contain the resulting ~[u8].</p>
<h2 id="struct-bsondocument">Struct <code>BsonDocument</code></h2>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">struct</span> BsonDocument {
    size: <span class="kw">i32</span>,
    fields: ~OrderedHashmap&lt;~<span class="kw">str</span>, Document&gt;,
}</code></pre>
<p>The type of a complete BSON document. Contains an ordered map of fields and values and the size of the document as i32.</p>
<h2 id="implementation-of-stdcmpeq-for-document">Implementation of <code>::std::cmp::Eq</code> for <code>Document</code></h2>
<p>Automatically derived.</p>
<h3 id="method-eq">Method <code>eq</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> eq(&amp;<span class="kw">self</span>, __arg_<span class="dv">0</span>: &amp;Document) -&gt; ::<span class="kw">bool</span></code></pre>
<h3 id="method-ne">Method <code>ne</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> ne(&amp;<span class="kw">self</span>, __arg_<span class="dv">0</span>: &amp;Document) -&gt; ::<span class="kw">bool</span></code></pre>
<h2 id="implementation-of-stdcloneclone-for-document">Implementation of <code>::std::clone::Clone</code> for <code>Document</code></h2>
<p>Automatically derived.</p>
<h3 id="method-clone">Method <code>clone</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> clone(&amp;<span class="kw">self</span>) -&gt; Document</code></pre>
<h2 id="implementation-for-objidfactory">Implementation for <code>ObjIdFactory</code></h2>
<h3 id="method-new">Method <code>new</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> new() -&gt; ObjIdFactory</code></pre>
<p>Get a new ObjIdFactory.</p>
<h3 id="method-oid">Method <code>oid</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> oid(&amp;<span class="kw">mut</span> <span class="kw">self</span>) -&gt; Document</code></pre>
<p>Generate an ObjectId.</p>
<h2 id="implementation-of-stdcmpeq-for-bsondocument">Implementation of <code>::std::cmp::Eq</code> for <code>BsonDocument</code></h2>
<p>Automatically derived.</p>
<h3 id="method-eq-1">Method <code>eq</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> eq(&amp;<span class="kw">self</span>, __arg_<span class="dv">0</span>: &amp;BsonDocument) -&gt; ::<span class="kw">bool</span></code></pre>
<h3 id="method-ne-1">Method <code>ne</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> ne(&amp;<span class="kw">self</span>, __arg_<span class="dv">0</span>: &amp;BsonDocument) -&gt; ::<span class="kw">bool</span></code></pre>
<h2 id="implementation-of-clone-for-bsondocument">Implementation of <code>Clone</code> for <code>BsonDocument</code></h2>
<h3 id="method-clone-1">Method <code>clone</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> clone(&amp;<span class="kw">self</span>) -&gt; BsonDocument</code></pre>
<h2 id="implementation-of-encoder-for-bsondocencoder">Implementation of <code>Encoder</code> for <code>BsonDocEncoder</code></h2>
<p>serialize::Encoder implementation.</p>
<h3 id="method-emit_nil">Method <code>emit_nil</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> emit_nil(&amp;<span class="kw">mut</span> <span class="kw">self</span>)</code></pre>
<h3 id="method-emit_uint">Method <code>emit_uint</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> emit_uint(&amp;<span class="kw">mut</span> <span class="kw">self</span>, v: <span class="kw">uint</span>)</code></pre>
<h3 id="method-emit_u8">Method <code>emit_u8</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> emit_u8(&amp;<span class="kw">mut</span> <span class="kw">self</span>, v: <span class="kw">u8</span>)</code></pre>
<h3 id="method-emit_u16">Method <code>emit_u16</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> emit_u16(&amp;<span class="kw">mut</span> <span class="kw">self</span>, v: <span class="kw">u16</span>)</code></pre>
<h3 id="method-emit_u32">Method <code>emit_u32</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> emit_u32(&amp;<span class="kw">mut</span> <span class="kw">self</span>, v: <span class="kw">u32</span>)</code></pre>
<h3 id="method-emit_u64">Method <code>emit_u64</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> emit_u64(&amp;<span class="kw">mut</span> <span class="kw">self</span>, v: <span class="kw">u64</span>)</code></pre>
<h3 id="method-emit_int">Method <code>emit_int</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> emit_int(&amp;<span class="kw">mut</span> <span class="kw">self</span>, v: <span class="kw">int</span>)</code></pre>
<h3 id="method-emit_i64">Method <code>emit_i64</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> emit_i64(&amp;<span class="kw">mut</span> <span class="kw">self</span>, v: <span class="kw">i64</span>)</code></pre>
<h3 id="method-emit_i32">Method <code>emit_i32</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> emit_i32(&amp;<span class="kw">mut</span> <span class="kw">self</span>, v: <span class="kw">i32</span>)</code></pre>
<h3 id="method-emit_i16">Method <code>emit_i16</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> emit_i16(&amp;<span class="kw">mut</span> <span class="kw">self</span>, v: <span class="kw">i16</span>)</code></pre>
<h3 id="method-emit_i8">Method <code>emit_i8</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> emit_i8(&amp;<span class="kw">mut</span> <span class="kw">self</span>, v: <span class="kw">i8</span>)</code></pre>
<h3 id="method-emit_bool">Method <code>emit_bool</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> emit_bool(&amp;<span class="kw">mut</span> <span class="kw">self</span>, v: <span class="kw">bool</span>)</code></pre>
<h3 id="method-emit_f64">Method <code>emit_f64</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> emit_f64(&amp;<span class="kw">mut</span> <span class="kw">self</span>, v: <span class="kw">f64</span>)</code></pre>
<h3 id="method-emit_f32">Method <code>emit_f32</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> emit_f32(&amp;<span class="kw">mut</span> <span class="kw">self</span>, v: <span class="kw">f32</span>)</code></pre>
<h3 id="method-emit_float">Method <code>emit_float</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> emit_float(&amp;<span class="kw">mut</span> <span class="kw">self</span>, v: <span class="kw">float</span>)</code></pre>
<h3 id="method-emit_str">Method <code>emit_str</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> emit_str(&amp;<span class="kw">mut</span> <span class="kw">self</span>, v: &amp;<span class="kw">str</span>)</code></pre>
<h3 id="method-emit_map_elt_key">Method <code>emit_map_elt_key</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> emit_map_elt_key(&amp;<span class="kw">mut</span> <span class="kw">self</span>, l: <span class="kw">uint</span>, f: &amp;<span class="kw">fn</span>(&amp;<span class="kw">mut</span> BsonDocEncoder))</code></pre>
<h3 id="method-emit_map_elt_val">Method <code>emit_map_elt_val</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> emit_map_elt_val(&amp;<span class="kw">mut</span> <span class="kw">self</span>, _: <span class="kw">uint</span>, f: &amp;<span class="kw">fn</span>(&amp;<span class="kw">mut</span> BsonDocEncoder))</code></pre>
<h3 id="method-emit_char">Method <code>emit_char</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> emit_char(&amp;<span class="kw">mut</span> <span class="kw">self</span>, c: <span class="kw">char</span>)</code></pre>
<h3 id="method-emit_struct">Method <code>emit_struct</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> emit_struct(&amp;<span class="kw">mut</span> <span class="kw">self</span>, _: &amp;<span class="kw">str</span>, _: <span class="kw">uint</span>, _: &amp;<span class="kw">fn</span>(&amp;<span class="kw">mut</span> BsonDocEncoder))</code></pre>
<h3 id="method-emit_enum">Method <code>emit_enum</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> emit_enum(&amp;<span class="kw">mut</span> <span class="kw">self</span>, _: &amp;<span class="kw">str</span>, _: &amp;<span class="kw">fn</span>(&amp;<span class="kw">mut</span> BsonDocEncoder))</code></pre>
<h3 id="method-emit_enum_variant">Method <code>emit_enum_variant</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> emit_enum_variant(&amp;<span class="kw">mut</span> <span class="kw">self</span>, _: &amp;<span class="kw">str</span>, _: <span class="kw">uint</span>, _: <span class="kw">uint</span>,
                     _: &amp;<span class="kw">fn</span>(&amp;<span class="kw">mut</span> BsonDocEncoder))</code></pre>
<h3 id="method-emit_enum_variant_arg">Method <code>emit_enum_variant_arg</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> emit_enum_variant_arg(&amp;<span class="kw">mut</span> <span class="kw">self</span>, _: <span class="kw">uint</span>, _: &amp;<span class="kw">fn</span>(&amp;<span class="kw">mut</span> BsonDocEncoder))</code></pre>
<h3 id="method-emit_enum_struct_variant">Method <code>emit_enum_struct_variant</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> emit_enum_struct_variant(&amp;<span class="kw">mut</span> <span class="kw">self</span>, _: &amp;<span class="kw">str</span>, _: <span class="kw">uint</span>, _: <span class="kw">uint</span>,
                            _: &amp;<span class="kw">fn</span>(&amp;<span class="kw">mut</span> BsonDocEncoder))</code></pre>
<h3 id="method-emit_enum_struct_variant_field">Method <code>emit_enum_struct_variant_field</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> emit_enum_struct_variant_field(&amp;<span class="kw">mut</span> <span class="kw">self</span>, _: &amp;<span class="kw">str</span>, _: <span class="kw">uint</span>,
                                  _: &amp;<span class="kw">fn</span>(&amp;<span class="kw">mut</span> BsonDocEncoder))</code></pre>
<h3 id="method-emit_struct_field">Method <code>emit_struct_field</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> emit_struct_field(&amp;<span class="kw">mut</span> <span class="kw">self</span>, _: &amp;<span class="kw">str</span>, _: <span class="kw">uint</span>, _: &amp;<span class="kw">fn</span>(&amp;<span class="kw">mut</span> BsonDocEncoder))</code></pre>
<h3 id="method-emit_tuple">Method <code>emit_tuple</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> emit_tuple(&amp;<span class="kw">mut</span> <span class="kw">self</span>, _: <span class="kw">uint</span>, _: &amp;<span class="kw">fn</span>(&amp;<span class="kw">mut</span> BsonDocEncoder))</code></pre>
<h3 id="method-emit_tuple_arg">Method <code>emit_tuple_arg</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> emit_tuple_arg(&amp;<span class="kw">mut</span> <span class="kw">self</span>, _: <span class="kw">uint</span>, _: &amp;<span class="kw">fn</span>(&amp;<span class="kw">mut</span> BsonDocEncoder))</code></pre>
<h3 id="method-emit_tuple_struct">Method <code>emit_tuple_struct</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> emit_tuple_struct(&amp;<span class="kw">mut</span> <span class="kw">self</span>, _: &amp;<span class="kw">str</span>, _: <span class="kw">uint</span>, _: &amp;<span class="kw">fn</span>(&amp;<span class="kw">mut</span> BsonDocEncoder))</code></pre>
<h3 id="method-emit_tuple_struct_arg">Method <code>emit_tuple_struct_arg</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> emit_tuple_struct_arg(&amp;<span class="kw">mut</span> <span class="kw">self</span>, _: <span class="kw">uint</span>, _: &amp;<span class="kw">fn</span>(&amp;<span class="kw">mut</span> BsonDocEncoder))</code></pre>
<h3 id="method-emit_option">Method <code>emit_option</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> emit_option(&amp;<span class="kw">mut</span> <span class="kw">self</span>, _: &amp;<span class="kw">fn</span>(&amp;<span class="kw">mut</span> BsonDocEncoder))</code></pre>
<h3 id="method-emit_option_none">Method <code>emit_option_none</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> emit_option_none(&amp;<span class="kw">mut</span> <span class="kw">self</span>)</code></pre>
<h3 id="method-emit_option_some">Method <code>emit_option_some</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> emit_option_some(&amp;<span class="kw">mut</span> <span class="kw">self</span>, _: &amp;<span class="kw">fn</span>(&amp;<span class="kw">mut</span> BsonDocEncoder))</code></pre>
<h3 id="method-emit_seq">Method <code>emit_seq</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> emit_seq(&amp;<span class="kw">mut</span> <span class="kw">self</span>, _: <span class="kw">uint</span>, _: &amp;<span class="kw">fn</span>(&amp;<span class="kw">mut</span> BsonDocEncoder))</code></pre>
<h3 id="method-emit_seq_elt">Method <code>emit_seq_elt</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> emit_seq_elt(&amp;<span class="kw">mut</span> <span class="kw">self</span>, _: <span class="kw">uint</span>, _: &amp;<span class="kw">fn</span>(&amp;<span class="kw">mut</span> BsonDocEncoder))</code></pre>
<h3 id="method-emit_map">Method <code>emit_map</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> emit_map(&amp;<span class="kw">mut</span> <span class="kw">self</span>, _: <span class="kw">uint</span>, _: &amp;<span class="kw">fn</span>(&amp;<span class="kw">mut</span> BsonDocEncoder))</code></pre>
<h2 id="implementation-of-encodablee-for-bsondocument-where-e-encoder">Implementation of <code>Encodable&lt;E&gt;</code> for <code>BsonDocument</code> where <code>&lt;E: Encoder&gt;</code></h2>
<p>Light wrapper around a typical Map implementation.</p>
<h3 id="method-encode">Method <code>encode</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> encode(&amp;<span class="kw">self</span>, encoder: &amp;<span class="kw">mut</span> E)</code></pre>
<h2 id="implementation-of-encodablee-for-document-where-e-encoder">Implementation of <code>Encodable&lt;E&gt;</code> for <code>Document</code> where <code>&lt;E: Encoder&gt;</code></h2>
<p>Encodable implementation for Document.</p>
<h3 id="method-encode-1">Method <code>encode</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> encode(&amp;<span class="kw">self</span>, encoder: &amp;<span class="kw">mut</span> E)</code></pre>
<p>After encode is run, the field 'buf' in the Encoder object will contain the encoded value. See bson_types.rs:203</p>
<h2 id="implementation-of-tostr-for-bsondocument">Implementation of <code>ToStr</code> for <code>BsonDocument</code></h2>
<h3 id="method-to_str">Method <code>to_str</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> to_str(&amp;<span class="kw">self</span>) -&gt; ~<span class="kw">str</span></code></pre>
<h2 id="implementation-for-bsondocument-where-self">Implementation for <code>BsonDocument</code> where <code>&lt;'self&gt;</code></h2>
<h3 id="method-to_bson">Method <code>to_bson</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> to_bson(&amp;<span class="kw">self</span>) -&gt; ~[<span class="kw">u8</span>]</code></pre>
<p>Convert this document to its binary BSON representation.</p>
<h3 id="method-iter">Method <code>iter</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> iter(&amp;<span class="ch">&#39;self self) -&gt; VecIterator&lt;&#39;</span>self, (@~<span class="kw">str</span>, @Document)&gt;</code></pre>
<p>Get a forwards iterator for this document.</p>
<h3 id="method-rev_iter">Method <code>rev_iter</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> rev_iter(&amp;<span class="ch">&#39;self self) -&gt; VecRevIterator&lt;&#39;</span>self, (@~<span class="kw">str</span>, @Document)&gt;</code></pre>
<p>Get a reverse iterator for this document.</p>
<h3 id="method-contains_key">Method <code>contains_key</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> contains_key(&amp;<span class="kw">self</span>, key: ~<span class="kw">str</span>) -&gt; <span class="kw">bool</span></code></pre>
<p>Check if this document contains the given key.</p>
<h3 id="method-find">Method <code>find</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> find&lt;<span class="ch">&#39;a&gt;(&amp;&#39;</span>a <span class="kw">self</span>, key: ~<span class="kw">str</span>) -&gt; <span class="kw">Option</span>&lt;&amp;<span class="ch">&#39;a Document&gt;</span></code></pre>
<p>Find the value for the given key, if it exists.</p>
<h3 id="method-put">Method <code>put</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> put(&amp;<span class="kw">mut</span> <span class="kw">self</span>, key: ~<span class="kw">str</span>, val: Document)</code></pre>
<p>Adds a key/value pair and updates size appropriately. Returns nothing.</p>
<h3 id="method-put_all">Method <code>put_all</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> put_all(&amp;<span class="kw">mut</span> <span class="kw">self</span>, pairs: ~[(~<span class="kw">str</span>, Document)])</code></pre>
<p>Adds a list of key/value pairs and updates size. Returns nothing.</p>
<h3 id="method-new-1">Method <code>new</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> new() -&gt; BsonDocument</code></pre>
<p>Returns a new BsonDocument struct. The default size is 5: 4 for the size integer and 1 for the terminating 0x0.</p>
<h3 id="method-fields_match">Method <code>fields_match</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> fields_match(&amp;<span class="kw">self</span>, other: &amp;BsonDocument) -&gt; <span class="kw">bool</span></code></pre>
<p>Compare two BsonDocuments to decide if they have the same fields. Returns true if every field except the _id field is matching. The _id field and the size are ignored. Two documents are considered to have matching fields even if their fields are not in the same order.</p>
<h2 id="implementation-for-document">Implementation for <code>Document</code></h2>
<p>Methods on documents.</p>
<h3 id="method-to_bson-1">Method <code>to_bson</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> to_bson(&amp;<span class="kw">self</span>) -&gt; ~[<span class="kw">u8</span>]</code></pre>
<p>Allows any document to be converted to its BSON-serialized representation.</p>
<h2 id="implementation-of-tostr-for-document">Implementation of <code>ToStr</code> for <code>Document</code></h2>
<h3 id="method-to_str-1">Method <code>to_str</code></h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> to_str(&amp;<span class="kw">self</span>) -&gt; ~<span class="kw">str</span></code></pre>
